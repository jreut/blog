#!/usr/bin/env node

const fs = require('fs')
const path = require('path')
const mustache = require('mustache')
const postcss = require('postcss')([
  require('cssnano'),
  require('postcss-cssnext')
])
const _ = require('pointfree-fantasy')
const Task = require('folktale/data/task')
const tocTask = require('../lib/toc')

const src = 'src'
const dist = 'dist'

const indexTemplate = path.join(src, 'index.mustache')
const indexDist = path.join(dist, 'index.html')
const entryTemplate = path.join(src, 'entry.mustache')
const entryDist = path.join(dist, 'entries')

//    readdir : String -> Task Err [String]
const readdir = Task.fromNodeback(fs.readdir)

//    readFile : String   -> Task Err String
const readFile = filepath =>
  Task
    .fromNodeback(fs.readFile)(filepath, { encoding: 'utf-8' })
    .mapRejected(console.error.bind(this))

//    writeFile : String   -> String|Buffer -> Task Err ()
const writeFile = filepath => contents =>
  Task
    .fromNodeback(fs.writeFile)(filepath, contents)
    .bimap(console.error.bind(this), () => console.log('Wrote %s', filepath))

const processStyle = basename => contents =>
  Task.fromPromised(() =>
    postcss.process(contents, {
      from: path.join(src, basename),
      to: path.join(dist, basename)
    })
  )()

const render = template => view => partials =>
  // TODO: memoize reading this file
  readFile(path.join(src, 'head.html'))
    .map(headPartial => mustache.render(
      template,
      view,
      Object.assign(partials, { head: headPartial })
    ))

//    setExit : Int    -> String  -> () -> ()
const setExit = status => message => () => {
  process.exitCode = status
  console.log(message)
}

const transformOneStylesheet = basename =>
  readFile(path.join(src, 'stylesheets', basename))
    .chain(processStyle(basename))
    .chain(writeFile(path.join(dist, 'stylesheets', basename)))

tocTask().chain(function (toc) {
  const writeStyles = readdir(path.join(src, 'stylesheets'))
    .chain(_.compose(Task.waitAll, _.map(_.compose(transformOneStylesheet, path.basename))))

  const writeIndex = readFile(indexTemplate)
    .chain(string => render(string)(toc)({}))
    .chain(writeFile(indexDist))

  const writeEntry = entry => {
    const file = entry.src
    const outputFile = path.join(entryDist, path.basename(file))

    return Task
      .waitAll([
        readFile(file),
        readFile(entryTemplate)
      ])
      .chain(([partial, entryTemplateString]) => render(entryTemplateString)({
        title: entry.name,
        timestamp: entry.created.timestamp
      })({
        entry: partial
      }))
      .chain(writeFile(outputFile))
  }

  const tasks = [
    writeIndex,
    writeStyles
  ].concat(toc.entries.map(writeEntry))

  return Task.waitAll(tasks)
}).run().listen({
  onCancelled: setExit(-1)('?'),
  onResolved: setExit(0)('✓'),
  onRejected: setExit(1)('✗')
})
